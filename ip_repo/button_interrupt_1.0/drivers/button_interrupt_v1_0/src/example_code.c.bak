#include "button_interrupt.h"
#include "stdio.h"
#include "stdlib.h"
#include "xscugic.h"
#include "platform.h"
#include "time.h"
#include "xil_exception.h"
#include "xil_io.h"
#include "xparameters.h"

/* xparameters.h is not generating the proper address ranges - must hardcore */
#define BTN_INTERRUPT_INTR_BASE 0x43c10000 /* from vivado address editor */
#define BTN_INTERRUPT_BASE  0x43c00000     /* from vivado address editor */

/* control register offset and bit positions */
#define BUTTON_INTERRUPT_CONFIG_REG BUTTON_INTERRUPT_S00_AXI_SLV_REG0_OFFSET
#define EN_REG (1 << 0) /* slv_reg0(0) */

/* interrupt id for button_interrupt IP Core */
#define BTN_IP_INTERRUPT_ID     XPAR_FABRIC_BUTTON_INTERRUPT_0_IRQ_INTR

/* define GIC */
#define INTC_DEVICE_ID                  XPAR_PS7_SCUGIC_0_DEVICE_ID

/* parameters matching the IP Cores settings for the GIC */
#define INT_EDGE_DETECTION 0x3  /* rising edge detection */
#define INT_PRIORITY       0xA0

/* instance of the IP Core */
static Xbtn_intr BTN_INST;

/* instance of the GIC */
static XScuGic Intc;

/* Function prototypes */
int SetupInterruptSystem();
void handler();

/* Main */
int main()
{
    init_platform();

    printf("\nEnable IP\n\r");
    BUTTON_INTERRUPT_mWriteReg(BTN_INTERRUPT_BASE,BUTTON_INTERRUPT_CONFIG_REG, EN_REG);

    printf("Enable interrupts\n\r");
    SetupInterruptSystem();

	xil_printf("Wait for Interrupts.... \n\r");
	while(1);

    BUTTON_INTERRUPT_mWriteReg(BTN_INTERRUPT_BASE,BUTTON_INTERRUPT_CONFIG_REG, 0);
	cleanup_platform();

	return 0;
}

/* Enables the GIC and connects the IP Core and Handler */
int SetupInterruptSystem()
{
	int 	xstatus;
	XScuGic	*IntcInstancePtr = &Intc;

	XScuGic_Config *IntcConfig;

	// Initialize the interrupt controller driver so that it is ready to use.
	IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
	if (NULL == IntcConfig) {
		return XST_FAILURE;
	}

	//IntcInstancePtr Pointer to ScuGic instance
	xstatus = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig,
					IntcConfig->CpuBaseAddress);
	if (xstatus != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Initialize the exception table and register the interrupt
	// controller handler with the exception table
	Xil_ExceptionInit();
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
				 (Xil_ExceptionHandler)XScuGic_InterruptHandler, IntcInstancePtr);

	// Enable non-critical exceptions
	Xil_ExceptionEnable();
	XScuGic_SetPriorityTriggerType(IntcInstancePtr, BTN_IP_INTERRUPT_ID,
					INT_PRIORITY, INT_EDGE_DETECTION);

	// Connect the interrupt handler that will be called when an
	// interrupt occurs for the device.
	xstatus = XScuGic_Connect(IntcInstancePtr, BTN_IP_INTERRUPT_ID,
				 (Xil_ExceptionHandler)handler, &BTN_INST);
	if (xstatus != XST_SUCCESS) {
		return xstatus;
	}

	// Enable the interrupt for the CustomIp device.
	XScuGic_Enable(IntcInstancePtr, BTN_IP_INTERRUPT_ID);

	// Enable the interrupts on the Core
	BUTTON_INTERRUPT_EnableInterrupt(BTN_INTERRUPT_INTR_BASE);

	return XST_SUCCESS;
}

/* Exception handler for button press interrupt */
void handler()
{
	static int count = 0;
	printf("interrupt %d\n\r",count++);
	BUTTON_INTERRUPT_ACK(BTN_INTERRUPT_INTR_BASE);
}
